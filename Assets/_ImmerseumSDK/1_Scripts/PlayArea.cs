using UnityEngine;
using System.Linq;
using System.Collections;
using System.Collections.Generic;

namespace Immerseum {
    namespace VRSimulator {
        /// <summary>Represents a Play Area generated by the Immerseum SDK.</summary>
        public class PlayArea : MonoBehaviour {
            private int _x1y1_Inner = 2;
            private int _x2y1_Inner = 3;
            private int _x1y2_Inner = 1;
            private int _x2y2_Inner = 0;

            private int _x1y1_Outer = 6;
            private int _x2y1_Outer = 7;
            private int _x1y2_Outer = 5;
            private int _x2y2_Outer = 4;

            /// <summary>Indicates whether the Play Area is currently visible within the scene.</summary>
            /// <value>
            ///   <strong>true</strong> if visible, <strong>false</strong> if not.</value>
            public bool isVisible {
                get {
                    return gameObject.activeInHierarchy;
                }
            }

            protected Vector2 _dimensions = Vector2.zero;
            /// <summary>Indicates the dimensions (width / depth) of the Play Area as a <see cref="!:https://docs.unity3d.com/ScriptReference/Vector2.html">Vector2</see>.</summary>
            /// <value>The dimensions of the Play Area, expressed as a <see cref="!:https://docs.unity3d.com/ScriptReference/Vector2.html">Vector2</see> where width
            /// (along the x-axis) is in the X value and depth (along the z-axis) is in the Y value.</value>
            public Vector2 dimensions {
                get {
                    switch (size) {
                        case PlayAreaSize.NotApplicable:
                            return Vector2.zero;
                        case PlayAreaSize.Custom:
                            return _dimensions;
                        case PlayAreaSize._200x150:
                            return new Vector2(2.0f, 1.5f);
                        case PlayAreaSize._300x225:
                            return new Vector2(3.0f, 2.25f);
                        case PlayAreaSize._400x300:
                            return new Vector2(4.0f, 3.0f);
                        default:
                            return new Vector2(width, depth);
                    }
                }
            }

            protected bool _isAvatarWithinBoundary = true;
            /// <summary>Indicates whether the user's avatar is currently inside of the Play Area's bounds.</summary>
            /// <value>
            ///   <strong>true</strong> if the user's avatar (camera and controllers) is currently inside the Play Area's bounds, otherwise <strong>false</strong>.</value>
            public bool isAvatarWithinBoundary {
                get {
                    return _isAvatarWithinBoundary;
                }
            }

            /// <summary>Indicates whether the user's avatar is currently outside of the Play Area's bounds.</summary>
            /// <value>
            ///   <strong>true</strong> if the user's avatar (camera or controllers) is outside of the Play Area's bounds, otherwise <strong>false</strong>.</value>
            public bool isAvatarOutsideBoundary {
                get {
                    return !isAvatarWithinBoundary;
                }
            }

            [Tooltip("The thickness of the Play Area's boundary / border when displayed in the scene, expressed in worldspace units (meters).")]
            /// <summary>The thickness of the Play Area's boundary / border when displayed in the scene, expressed in worldspace units (meters).</summary>
            /// <value>The thickness of the Play Area's boundary/borders when displayed in the scene, expressed in worldspace units (meters).</value>
            public float borderThickness = 0.15f;

            [Tooltip("The Color to apply when rendering the Play Area.")]
            /// <summary>The <see cref="!:https://docs.unity3d.com/ScriptReference/Color.html">Color</see> to apply when rendering the Play Area.</summary>
            /// <value>A Unity <see cref="!:https://docs.unity3d.com/ScriptReference/Color.html">Color</see>.</value>
            public Color color = new Color(0, 255, 255, 255);

            [Tooltip("The Material to apply when rendering the Play Area.")]
            /// <summary>The <see cref="!:https://docs.unity3d.com/ScriptReference/Material.html">Material</see> that should be used when rendering the Play Area.</summary>
            /// <value>A <see cref="!:https://docs.unity3d.com/ScriptReference/Material.html">Material</see>.</value>
            public Material material;

            [Tooltip("The list of points (sequence matters!) where each value represents a vertex in the Play Area's boundary.")]
            /// <summary>A <see cref="!:https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx">List</see> of <see cref="!:https://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</see> values where each value represents a vertex in the Play Area's boundary.</summary>
            /// <value>A <see cref="!:https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx">List</see> of <see cref="!:https://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</see> values where each value represents a vertex in the Play Area's boundary expressed in worldspace units.</value>
            public List<Vector3> verticesList;

            [Tooltip("Applies if the Play Area is a regular shape. Two sets of four vertices each that correspond to the Outer boundary of the Play Area and the Inner boundary of the Play Area.")]
            /// <summary>An array of eight vertices that demarcate the corners of the Play Area's outer and inner boundaries.</summary>
            /// <value>
            ///   <para>An array of eight (8) vertices expressed as worldspace <see cref="!:https://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</see>
            /// values.</para>
            ///   <para>The first four represent the outer edge of the Play Area's border, starting from the top left (forward left from the user's perspective) corner and
            /// proceeding in a clockwise direction around the Play Area.</para>
            ///   <para>The second four represent the inner edge of the Play Area's border, starting from the top left (forward left from the user's perspective) corner and
            /// proceeding in a clockwise direction around the Play Area.</para>
            /// </value>
            public Vector3[] cornerVertices = new Vector3[8];

            protected bool _hasChildren {
                get {
                    return transform.childCount > 0;
                }
            }

            /// <summary>Indicates the width (along the x-axis) of the Play Area.</summary>
            /// <value>The width (along the x-axis) of the Play Area, expressed in worldspace units (meters) and calculated from the outer boundary.</value>
            /// <exception caption="Data Misaligned Exception" cref="System.DataMisalignedException">Play Area Size is Not Applicable, so cannot return a value.</exception>
            public float width {
                get {
                    if (size == PlayAreaSize.Calibrated) {
                        float[] xValueArray = new float[verticesList.Count];
                        int n = xValueArray.Length;

                        for (int x = 0; x < n; x++) {
                            xValueArray[x] = verticesList[x].x;
                        }

                        float maxX = xValueArray.Max();
                        float minX = xValueArray.Min();

                        return Mathf.Abs(maxX - minX);
                    } else if (size != PlayAreaSize.NotApplicable) {
                        return Mathf.Abs(cornerVertices[_x2y2_Outer].x - cornerVertices[_x1y2_Outer].x);
                    }
                    throw new System.DataMisalignedException("[ImmerseumSDK] Play Area Size is Not Applicable, so cannot return width.");
                }
            }

            /// <summary>
            ///   <para>The height (along the y-axis) of the Play Area.</para>
            ///   <innovasys:widget type="Info Box" layout="block" xmlns:innovasys="http://www.innovasys.com/widgets">
            ///     <innovasys:widgetproperty layout="block" name="Content">The Immerseum Play Area always has a fixed height of
            ///     <strong>0.01</strong>.</innovasys:widgetproperty>
            ///   </innovasys:widget>
            /// </summary>
            public float height {
                get {
                    return 0.01f;
                }
            }

            [Tooltip("The vertical position (height) at which the Play Area is positioned. Should be greater than the floor's height (typically greater than zero).")]
            /// <summary>The vertical position (height) at which the Play Area is positioned. Should be greater than the floor's height (typically greater than zero).</summary>
            /// <value>The distance above the <strong>Y:0</strong> point to position the Play Area expressed in worldspace units (meters).</value>
            public float heightOffset = 0.1f;

            /// <summary>Indicates the depth (along the z-axis) of the Play Area.</summary>
            /// <value>The depth of the Play Area along the z-axis, expressed in worldspace units (meters), calculated from the Play Area's Outer boundary.</value>
            /// <exception caption="Data Misaligned Exception" cref="System.DataMisalignedException">Play Area Size is Not Applicable, so cannot return a value.</exception>
            public float depth {
                get {
                    if (size == PlayAreaSize.Calibrated) {
                        float[] zValueArray = new float[verticesList.Count];
                        int n = zValueArray.Length;

                        for (int x = 0; x < n; x++) {
                            zValueArray[x] = verticesList[x].z;
                        }

                        float maxZ = zValueArray.Max();
                        float minZ = zValueArray.Min();

                        return Mathf.Abs(maxZ - minZ);
                    } else if (size != PlayAreaSize.NotApplicable) {
                        return Mathf.Abs(cornerVertices[_x1y1_Outer].z - cornerVertices[_x1y2_Outer].z);
                    }
                    throw new System.DataMisalignedException("[ImmerseumSDK] Play Area Size is Not Applicable, so cannot return Depth.");
                }
            }

            protected PlayAreaSize _size = PlayAreaSize.NotApplicable;
            /// <summary>The <see cref="PlayAreaSize" /> that determines the width/depth of this Play Area.</summary>
            /// <value>The <see cref="PlayAreaSize" /> that is applied to this Play Area.</value>
            public PlayAreaSize size {
                get {
                    return _size;
                }
                set {
                    _size = value;
                    setPlayAreaSize(_size);
                }
            }

            protected float _heightAdjustment = 0f;

            /// <summary>Changes the parent of the Play Area gameobject in the scene hierarchy.</summary>
            /// <param name="target">The <see cref="!:https://docs.unity3d.com/Manual/class-Transform.html">Transform</see> which should become the Play Area's parent in the scene hierarchy. Use
            /// <strong>null</strong> to make the Play Area a root object.</param>
            public void setParent(Transform target) {
                transform.parent = target;
            }


            /// <summary>Applies the $$camera rig$$'s SteamVR_PlayArea component size and appearance settings to the simulated Play Area.</summary>
            public void applySteamPlayAreaSettings() {
                if (PlayAreaManager.hasSteamPlayArea) {
                    color = PlayAreaManager.getSteamPlayArea.color;
                    MeshRenderer steamPlayAreaMeshRenderer = PlayAreaManager.getSteamPlayArea.GetComponent<MeshRenderer>();
                    material = steamPlayAreaMeshRenderer.material;
                    borderThickness = PlayAreaManager.getSteamPlayArea.borderThickness;
                    switch (PlayAreaManager.getSteamPlayArea.size) {
                        case SteamVR_PlayArea.Size._200x150:
                            setPlayAreaSize(PlayAreaSize._200x150);
                            break;
                        case SteamVR_PlayArea.Size._300x225:
                            setPlayAreaSize(PlayAreaSize._300x225);
                            break;
                        case SteamVR_PlayArea.Size._400x300:
                            setPlayAreaSize(PlayAreaSize._400x300);
                            break;
                        case SteamVR_PlayArea.Size.Calibrated:
                            setPlayAreaSize(PlayAreaSize.Calibrated);
                            break;
                    }
                    return;
                }
                Debug.LogError("[ImmerseumSDK] Attempted to apply Steam Play Area settings to simulated Play Area, but there was no Steam Play Area found. No changes made.");
                return;
            }

            /// <summary>
            ///   <para>Applies the Play Area's size and appearance settings to the SteamVR_PlayArea component attached to the $$camera rig$$.</para>
            ///   <innovasys:widget type="Warning Box" layout="block" xmlns:innovasys="http://www.innovasys.com/widgets">
            ///     <innovasys:widgetproperty layout="block" name="Content">If your Play Area's <strong>size</strong> does not match one of the SteamVR_PlayArea's allowed
            ///     sizes, will default to 3m x 2.25m.</innovasys:widgetproperty>
            ///   </innovasys:widget>
            /// </summary>
            public void applySettingsToSteamPlayArea() {
                if (PlayAreaManager.hasSteamPlayArea) {
                    MeshRenderer steamPlayAreaMeshRenderer = PlayAreaManager.getSteamPlayArea.GetComponent<MeshRenderer>();
                    PlayAreaManager.getSteamPlayArea.borderThickness = borderThickness;
                    PlayAreaManager.getSteamPlayArea.color = color;
                    steamPlayAreaMeshRenderer.material = material;
                    switch (size) {
                        case PlayAreaSize._200x150:
                            PlayAreaManager.getSteamPlayArea.size = SteamVR_PlayArea.Size._200x150;
                            break;
                        case PlayAreaSize._300x225:
                            PlayAreaManager.getSteamPlayArea.size = SteamVR_PlayArea.Size._300x225;
                            break;
                        case PlayAreaSize._400x300:
                            PlayAreaManager.getSteamPlayArea.size = SteamVR_PlayArea.Size._400x300;
                            break;
                        case PlayAreaSize.Calibrated:
                            PlayAreaManager.getSteamPlayArea.size = SteamVR_PlayArea.Size.Calibrated;
                            break;
                        default:
                            goto case PlayAreaSize._300x225;
                    }
                    return;
                }
                Debug.LogWarning("[ImmerseumSDK] Attempted to apply simulated Play Area settings to the Steam Play Area, but there was no Steam Play Area found. No changes made.");
                return;
            }

            /// <summary>Applies the Play Area's color to the Oculus Boundary system.</summary>
            public void applyColorToOculusPlayArea() {
#if UNITY_EDITOR_WIN || UNITY_STANDALONE_WIN
                if (PlayAreaManager.hasOculusPlayArea) {
                    OVRBoundary.BoundaryLookAndFeel oculusBoundaryAppearance = new OVRBoundary.BoundaryLookAndFeel();
                    oculusBoundaryAppearance.Color = color;
                    OVRManager.boundary.SetLookAndFeel(oculusBoundaryAppearance);
                    return;
                }
#endif
                Debug.LogWarning("[ImmerseumSDK] Attempted to apply simulated Play Area settings to the Oculus Play Area, but there was no Oculus Play Area found. No changes made.");
                return;
            }

            /// <summary>Sets the <see cref="size">size</see> of the Play Area to one of the preconfigured <see cref="PlayAreaSize" /> values.</summary>
            /// <param name="value">The <see cref="PlayAreaSize" /> that the Play Area should adopt.</param>
            public void setPlayAreaSize(PlayAreaSize value) {
                _size = value;
                switch (value) {
                    case PlayAreaSize.NotApplicable:
                        if (PlayAreaManager.isPlayAreaDisplayedAlways && HMDSimulator.isUsingSteamRig && HMDSimulator.isHMDConnected) {
                            if (HMDSimulator.logDiagnostics) {
                                Debug.LogWarning("[ImmerseumSDK] Applying Play Area size and rendering properties from the SteamVR_PlayArea attached to the Camera Rig.");
                            }
                            applySteamPlayAreaSettings();
                            break;
                        } else if (PlayAreaManager.isPlayAreaDisplayedAlways && HMDSimulator.isUsingSteamRig) {
                            Debug.LogWarning("[ImmerseumSDK] Play Area is set to always display, but size has been set to Not Applicable and calibration is unavailable without a headset connected. Falling back to a default Play Area of 3m x 2.25m.");
                            goto case PlayAreaSize._300x225;
                        } else if (PlayAreaManager.isPlayAreaDisplayedAlways) {
                            Debug.LogWarning("[ImmerseumSDK] Play Area is set to always display, but size has been set to Not Applicable. The Oculus Rift does not have a default play area to fallback to, so no Play Area will be displayed.");
                        }
                        gameObject.SetActive(false);
                        break;
                    case PlayAreaSize._200x150:
                        setDimensions(2f, 1.5f);
                        break;
                    case PlayAreaSize._300x225:
                        setDimensions(3f, 2.25f);
                        break;
                    case PlayAreaSize._400x300:
                        setDimensions(4f, 3f);
                        break;
                    case PlayAreaSize.Calibrated:
                        setDimensions();
                        break;
                    case PlayAreaSize.Custom:
                        Vector2 dimensions = PlayAreaManager.customPlayAreaDimensions;
                        setDimensions(dimensions);
                        break;
                }
            }
            /// <summary>Sets the <see cref="size">size</see> of the Play Area, supporting the use of custom dimensions.</summary>
            /// <param name="size">The <see cref="PlayAreaSize" /> that the Play Area should adopt.</param>
            /// <param name="dimensions">If <strong>size</strong> is equal to <see cref="PlayAreaSize.Custom" />, the dimensions (width along the x-axis, depth along the z-axis) of the custom-sized Play Area
            /// expressed as a <see cref="!:https://docs.unity3d.com/ScriptReference/Vector2.html">Vector2</see>.</param>
            public void setPlayAreaSize(PlayAreaSize size, Vector2 dimensions) {
                if (size != PlayAreaSize.Custom) {
                    setPlayAreaSize(size);
                    return;
                }
                _size = size;
                setDimensions(dimensions);
            }
            /// <summary>
            ///   <para>Sets the <see cref="size">size</see> of the Play Area based on provided dimensions.</para>
            ///   <innovasys:widget type="Info Box" layout="block" xmlns:innovasys="http://www.innovasys.com/widgets">
            ///     <innovasys:widgetproperty layout="block" name="Content">If the dimensions provided correspond to one of the existing standard <see cref="PlayAreaSize" /> values, that
            ///     value will be applied. Otherwise, a Custom size will be applied.</innovasys:widgetproperty>
            ///   </innovasys:widget>
            /// </summary>
            /// <param name="dimensions">The dimensions of the Play Area, expressed as a <see cref="!:https://docs.unity3d.com/ScriptReference/Vector2.html">Vector2</see> where width
            /// (along the x-axis) is the X position and depth (along the z-axis) is the Y position.</param>
            public void setPlayAreaSize(Vector2 dimensions) {
                if (dimensions.x == 2f && dimensions.y == 1.5f) {
                    _size = PlayAreaSize._200x150;
                } else if (dimensions.x == 3f && dimensions.y == 2.25f) {
                    _size = PlayAreaSize._300x225;
                } else if (dimensions.x == 4f && dimensions.y == 3f) {
                    _size = PlayAreaSize._400x300;
                } else {
                    _size = PlayAreaSize.Custom;
                }
                setDimensions(dimensions);
            }
            /// <summary>Sets the <see cref="size">size</see> of the Play Area based on a collection of vertex points that define the boundary.</summary>
            /// <param name="vertices">A <see cref="!:https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx">List</see> of <see cref="!:https://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</see> points in worldspace that represent the vertexes of the (possibly
            /// irregularly-shaped) Play Area boundary.</param>
            public void setPlayAreaSize(List<Vector3> vertices) {
                _size = PlayAreaSize.Custom;
                verticesList = vertices;
                for (int x = 0; x < 8; x++) {
                    cornerVertices[x] = Vector3.zero;
                }
                renderVertices(verticesList.ToArray());
            }

            /// <summary>Adjusts the dimensions of the Play Area to the width/depth provided.</summary>
            /// <param name="dimensions">The width (along the x-axis) and depth (along the z-axis) of the Play Area, expressed as a <see cref="!:https://docs.unity3d.com/ScriptReference/Vector2.html">Vector2</see> (X, Z).</param>
            public void setDimensions(Vector2 dimensions) {
                setDimensions(dimensions.x, dimensions.y);
            }
            /// <summary>Adjusts the dimensions of the Play Area to the width/depth provided.</summary>
            /// <param name="newWidth">The width (along the x-axis) that the Play Area should adopt, expressed in worldspace units (equivalent to meters).</param>
            /// <param name="newDepth">The depth (along the z-axis) that the Play Area should adopt, expressed in worldspace units (equivalent to meters).</param>
            public void setDimensions(float newWidth, float newDepth) {
                _dimensions = new Vector2(newWidth, newDepth);

                cornerVertices[_x1y1_Outer] = new Vector3(-(newWidth / 2), 0f, newDepth / 2);
                cornerVertices[_x2y1_Outer] = new Vector3(newWidth / 2, 0f, newDepth / 2);
                cornerVertices[_x1y2_Outer] = new Vector3(-(newWidth / 2), 0f, -(newDepth / 2));
                cornerVertices[_x2y2_Outer] = new Vector3(newWidth / 2, -(newDepth / 2));

                cornerVertices[_x1y1_Inner] = cornerVertices[_x1y1_Outer] + new Vector3(borderThickness, 0f, -borderThickness);
                cornerVertices[_x2y1_Inner] = cornerVertices[_x2y1_Outer] + new Vector3(-borderThickness, 0f, -borderThickness);
                cornerVertices[_x1y2_Inner] = cornerVertices[_x1y2_Outer] + new Vector3(borderThickness, 0f, borderThickness);
                cornerVertices[_x2y2_Inner] = cornerVertices[_x2y2_Outer] + new Vector3(-borderThickness, 0f, borderThickness);

                transform.localScale = new Vector3(width, height, depth);

                int n = cornerVertices.Length;
                verticesList.Clear();
                for (int x = 0; x < n; x++) {
                    verticesList.Add(cornerVertices[x]);
                }
                renderSquarePlayAreaMesh();
            }

            /// <summary>Adjusts the dimensions of the Play Area to its configured <see cref="size">size</see>.</summary>
            public void setDimensions() {
                if (PlayAreaManager.isHMDPlayAreaSizeCalibrated == false) {
                    if (HMDSimulator.logDiagnostics) {
                        Debug.LogWarning("[ImmerseumSDK] Attempted to set Play Area dimensions using HMD calibration, but no calibration is available. Falling back to 3m x 2.25m.");
                    }
                    setPlayAreaSize(PlayAreaSize._300x225);
                    return;
                }
                if (HMDSimulator.logDiagnostics) {
                    Debug.LogWarning("[ImmerseumSDK] Attempting to calibrate Play Area.");
                }
                calibratePlayArea();
            }

            /// <summary>Sets the <see cref="!:https://docs.unity3d.com/ScriptReference/Material.html">Material</see> and <see cref="!:https://docs.unity3d.com/ScriptReference/Color.html">Color</see> that are applied to the Play Area.</summary>
            /// <param name="newMaterial">The new <see cref="!:https://docs.unity3d.com/ScriptReference/Material.html">Material</see> to apply to the Play Area.</param>
            /// <param name="newColor">The new <see cref="!:https://docs.unity3d.com/ScriptReference/Color.html">Color</see> to apply to the Play Area.</param>
            public void setMaterial(Material newMaterial, Color newColor) {
                color = newColor;
                if (newMaterial != null) {
                    material = newMaterial;
                }
                if (material != null) {
                    material.color = color;
                }
            }

            void renderSquarePlayAreaMesh() {
                destroyChildBoundaries();
                renderPlayAreaBoundary(0, verticesList[_x1y2_Outer].x, verticesList[_x2y2_Outer].x, verticesList[_x2y2_Inner].z, verticesList[_x2y2_Outer].z, new Vector3(0f, 0f, transform.localScale.z / 2));
                renderPlayAreaBoundary(1, verticesList[_x1y2_Outer].x, verticesList[_x1y2_Inner].x, verticesList[_x1y1_Outer].z, verticesList[_x1y2_Outer].z, new Vector3(transform.localScale.x / 2, 0f, 0f));
                renderPlayAreaBoundary(2, verticesList[_x1y2_Outer].x, verticesList[_x2y2_Outer].x, verticesList[_x2y2_Inner].z, verticesList[_x2y2_Outer].z, new Vector3(0f, 0f, -(transform.localScale.z / 2)));
                renderPlayAreaBoundary(3, verticesList[_x1y2_Outer].x, verticesList[_x1y2_Inner].x, verticesList[_x1y1_Outer].z, verticesList[_x1y2_Outer].z, new Vector3(-(transform.localScale.x / 2), 0f, 0f));
            }

            void destroyChildBoundaries() {
                if (transform.childCount == 0) {
                    return;
                }
                int n = transform.childCount;
                for (int x = 0; x < n; x++) {
                    GameObject child = transform.GetChild(x).gameObject;
                    Destroy(child);
                }
            }

            void renderPlayAreaBoundary(int index, float left, float right, float top, float bottom, Vector3 localPosition) {
                GameObject playAreaBoundary = GameObject.CreatePrimitive(UnityEngine.PrimitiveType.Cube);

                MeshRenderer meshRenderer = playAreaBoundary.GetComponent<MeshRenderer>();
                if (material == null) {
                    Shader standardShader = Shader.Find("Standard");
                    material = new Material(standardShader);
                }
                material.color = color;
                meshRenderer.material = material;

                string objectName = "PlayAreaBoundary (" + index.ToString() + ")";
                playAreaBoundary.name = objectName;
                float _width = (right - left) / 1.065f;
                float _length = (top - bottom) / 1.08f;
                playAreaBoundary.transform.localScale = new Vector3(_width, height, _length);
                Destroy(playAreaBoundary.GetComponent<BoxCollider>());
                playAreaBoundary.layer = LayerMask.NameToLayer("Ignore Raycast");
                playAreaBoundary.transform.parent = this.transform;
                playAreaBoundary.transform.position = localPosition;
            }

            /// <summary>Sets the <see cref="size">size</see> of the Play Area based on a collection of vertex points that define the boundary.</summary>
            /// <param name="vertexPoints">A <see cref="!:https://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx">List</see> of <see cref="!:https://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</see> points in
            /// worldspace that represent the vertexes of the (possibly irregularly-shaped) Play Area boundary.</param>
            public void setVertices(List<Vector3> vertexPoints) {
                setPlayAreaSize(vertexPoints);
            }

            /// <summary>Adjusts the sizing / dimensions of the Play Area to correspond to the $$HMD Play Area$$ and its calibrated settings (if available).</summary>
            public void calibratePlayArea() {
                verticesList = PlayAreaManager.getHMDPlayAreaVerticesList;
                if (verticesList.Count == 0) {
                    if (HMDSimulator.logDiagnostics) {
                        Debug.LogWarning("[ImmerseumSDK] HMD Play Area returned an empty list of vertices. Falling back to default 3m x 2.25m play area.");
                    }
                    setPlayAreaSize(PlayAreaSize._300x225);
                }
                Vector3[] verticesArray = verticesList.ToArray();
                int n = verticesArray.Length;
                if (HMDSimulator.logDiagnostics) {
                    Debug.LogWarning("[ImmerseumSDK] RECEIVED " + n.ToString() + " vertices from Calibration.");
                }
                for (int x = 0; x < n; x++) {
                    verticesArray[x].y = heightOffset;
                }
                renderVertices(verticesArray);
            }

            protected void renderVertices(Vector3[] verticesArray) {
                int n = verticesArray.Length;
                switch (n) {
                    case 8:
                        renderInnerOuterBounds(verticesArray);
                        break;
                    case 4:
                        renderInnerBounds(verticesArray);
                        break;
                    case 1:
                    case 0:
                        setPlayAreaSize(PlayAreaSize.NotApplicable);
                        break;
                    default:
                        renderLine(verticesArray);
                        break;
                }
            }

            protected void renderInnerOuterBounds(Vector3[] verticesArray) {
                Vector3[] _splitVerticesArray = Rectangle.getInnerOuterVertices(verticesArray);
                Rectangle playAreaBounds = new Immerseum.Rectangle(_splitVerticesArray);
                setCornerVertices(playAreaBounds);
                setDimensions(width, depth);
            }

            protected void setCornerVertices(Rectangle playAreaBounds) {
                cornerVertices[_x1y2_Outer] = playAreaBounds.outerA;
                cornerVertices[_x2y2_Outer] = playAreaBounds.outerB;
                cornerVertices[_x2y1_Outer] = playAreaBounds.outerC;
                cornerVertices[_x1y1_Outer] = playAreaBounds.outerD;

                cornerVertices[_x1y2_Inner] = playAreaBounds.innerA;
                cornerVertices[_x2y2_Inner] = playAreaBounds.innerB;
                cornerVertices[_x2y1_Inner] = playAreaBounds.innerC;
                cornerVertices[_x1y1_Inner] = playAreaBounds.innerD;

                int n = cornerVertices.Length;
                verticesList.Clear();
                for (int x = 0; x < n; x++) {
                    verticesList.Add(cornerVertices[x]);
                }
            }

            protected void renderInnerBounds(Vector3[] innerVerticesArray) {
                innerVerticesArray = Rectangle.sortFourPointsClockwise(innerVerticesArray);
                Vector3[] outerVerticesArray = new Vector3[4];

                outerVerticesArray[0] = new Vector3(innerVerticesArray[0].x - borderThickness, innerVerticesArray[1].y, innerVerticesArray[0].z + borderThickness);
                outerVerticesArray[1] = new Vector3(innerVerticesArray[1].x + borderThickness, innerVerticesArray[1].y, innerVerticesArray[1].z + borderThickness);
                outerVerticesArray[2] = new Vector3(innerVerticesArray[2].x + borderThickness, innerVerticesArray[2].y, innerVerticesArray[2].z - borderThickness);
                outerVerticesArray[3] = new Vector3(innerVerticesArray[3].x + borderThickness, innerVerticesArray[3].y, innerVerticesArray[3].z + borderThickness);

                Vector3[] playAreaVertices = new Vector3[8];
                outerVerticesArray.CopyTo(playAreaVertices, 0);
                innerVerticesArray.CopyTo(playAreaVertices, 4);

                Rectangle playAreaBounds = new Immerseum.Rectangle(playAreaVertices);
                setCornerVertices(playAreaBounds);
                setDimensions(width, depth);
            }

            protected void renderLine(Vector3[] verticesArray) {
                List<Vector3> _vertexList = new List<Vector3>();
                int n = verticesArray.Length;
                for (int x = 0; x < n; x++) {
                    _vertexList.Add(verticesArray[x]);
                }
                if (verticesArray[n - 1] != verticesArray[0]) {
                    _vertexList.Add(verticesArray[0]);
                }

                for (int x = 1; x < n; x++) {
                    bool isRightAngleTurn = Shapes.isRightAngleTurn(_vertexList[x], _vertexList[x + 1]);
                    Vector3[] bisectingVertexArray = new Vector3[3];
                    if (isRightAngleTurn) {
                        bisectingVertexArray = Shapes.getBisectingVertices(_vertexList[x - 1], _vertexList[x], _vertexList[x + 1]);
                        _vertexList[x] = bisectingVertexArray[0];
                        _vertexList.Insert(x, bisectingVertexArray[1]);
                    }
                }

                int m = _vertexList.Count;
                Vector3[] _finalVertexArray = _vertexList.ToArray();

                LineRenderer playAreaLineRenderer = gameObject.AddComponent<LineRenderer>();
                playAreaLineRenderer.SetColors(color, color);
                playAreaLineRenderer.SetWidth(borderThickness, borderThickness);
                playAreaLineRenderer.SetVertexCount(m);
                playAreaLineRenderer.SetPositions(_finalVertexArray);
            }

            /// <summary>Generates and applies one <see cref="!:https://docs.unity3d.com/ScriptReference/Collider.html">Colliders</see> to the Play Area as applicable.</summary>
            public void applyColliders() {
                if (size != PlayAreaSize.NotApplicable) {
                    BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();
                    boxCollider.isTrigger = true;
                    boxCollider.name = gameObject.name + "_Collider";
                    boxCollider.size = new Vector3(width, Mathf.Abs(HMDSimulator.getCamera.position.y) * 1.10f, depth);
                    boxCollider.center = Vector3.zero;
                } else {
                    throw new System.DataMisalignedException("Play Area Size is Not Applicable. Cannot apply Collider.");
                }
            }

            /// <summary>Repositions the Play Area at the provided coordinates.</summary>
            /// <param name="targetPoint">A <see cref="!:https://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</see> coordinate in worldspace units.</param>
            public void move(Vector3 targetPoint) {
                transform.position = targetPoint;
            }

            /// <summary>Positions the Play Area to be centered on the user's avatar.</summary>
            public void recenterOnAvatar() {
                if (HMDSimulator.isCameraRigInTransform(transform)) {
                    transform.localPosition = Vector3.zero;
                } else {
                    transform.position = HMDSimulator.CameraRig.root.position;
                }
            }

            void OnCollisionEnter(Collision other) {
                if (HMDSimulator.isCameraRigInTransform(other.transform)) {
                    _isAvatarWithinBoundary = true;
                }
            }

            void OnCollisionStay(Collision other) {
                if (HMDSimulator.isCameraRigInTransform(other.transform)) {
                    _isAvatarWithinBoundary = true;
                }
            }

            void OnCollisionExit(Collision other) {
                if (HMDSimulator.isCameraRigInTransform(other.transform)) {
                    _isAvatarWithinBoundary = false;
                }
            }

            Vector3 getNearestPoint(Vector3 point, Vector3[] vertexArray) {
                Vector3 nearestVertex = Vector3.zero;

                //                point = transform.InverseTransformPoint(point);

                float minDistanceSqr = Mathf.Infinity;

                int n = vertexArray.Length;
                for (int x = 0; x < n; x++) {
                    Vector3 difference = point - vertexArray[x];
                    float distSqr = difference.sqrMagnitude;

                    if (distSqr < minDistanceSqr) {
                        minDistanceSqr = distSqr;
                        nearestVertex = vertexArray[x];
                    }
                }
                return nearestVertex;
            }

            Vector3 getNearestVertex(Vector3 point) {
                Vector3 nearestVertex = Vector3.zero;
                //                point = transform.InverseTransformPoint(point);

                nearestVertex = getNearestPoint(point, verticesList.ToArray());
                return nearestVertex;
            }

            /// <summary>Returns the shortest distance from the point to the Play Area's bounds.</summary>
            /// <param name="point">The point from which a distance to the Play Area's bounds is calculated.</param>
            /// <param name="unsigned">Determines whether the distance is returned as an unsigned (absolute) value. <strong>True</strong> by default.</param>
            /// <param name="ignoreHeight">Determines whether the distance should ignore differences in height between the point and the Play Area's bounds. <strong>True</strong> by default.</param>
            /// <returns>The distance expressed in worldspace units (equivalent to meters).</returns>
            public float getDistance(Vector3 point, bool unsigned = true, bool ignoreHeight = true) {
                float distance = Mathf.Infinity;

                if (_hasChildren) {
                    Transform[] childTransforms = new Transform[4];
                    float minDistance = Mathf.Infinity;
                    for (int x = 0; x < 4; x++) {
                        childTransforms[x] = transform.GetChild(x);
                        if (childTransforms[x].localScale.x > childTransforms[x].localScale.z) {
                            minDistance = Mathf.Abs(childTransforms[x].position.z - point.z);
                        } else {
                            minDistance = Mathf.Abs(childTransforms[x].position.x - point.x);
                        }
                        if (minDistance < distance) {
                            distance = minDistance;
                        }
                    }
                } else {
                    Vector3 nearestVertex = getNearestVertex(point);

                    if (ignoreHeight) {
                        Vector2 nearestXZ = new Vector2(nearestVertex.x, nearestVertex.z);
                        Vector2 pointXZ = new Vector2(point.x, point.z);
                        distance = Vector2.Distance(pointXZ, nearestXZ);
                    } else {
                        distance = Vector3.Distance(point, nearestVertex);
                    }

                    if (unsigned) {
                        return Mathf.Abs(distance);
                    }
                }
                return distance;
            }
            /// <summary>Returns the shortest distance from the Play Area's bounds to the user's avatar as defined by three points.</summary>
            /// <param name="cameraPosition">The position in worldspace of the camera (user's head/eyes).</param>
            /// <param name="leftControllerPosition">The position in worldspace of the left-hand controller.</param>
            /// <param name="rightControllerPosition">The position in worldspace of the right-hand controller.</param>
            /// <param name="ignoreHeight">Determines whether the distance should ignore differences in height between the points and the Play Area's bounds. <strong>True</strong> by default.</param>
            /// <param name="unsigned">Determines whether the distance is returned as an unsigned (absolute) value. <strong>True</strong> by default.</param>
            /// <returns>The distance expressed in worldspace units (equivalent to meters).</returns>
            public float getDistance(Vector3 cameraPosition, Vector3 leftControllerPosition, Vector3 rightControllerPosition, bool unsigned = true, bool ignoreHeight = true) {
                float[] distanceArray = new float[3];
                distanceArray[0] = getDistance(cameraPosition, unsigned, ignoreHeight);
                distanceArray[1] = getDistance(leftControllerPosition, unsigned, ignoreHeight);
                distanceArray[2] = getDistance(rightControllerPosition, unsigned, ignoreHeight);

                float distance = distanceArray.Min();

                if (unsigned) {
                    return Mathf.Abs(distance);
                }
                return distance;
            }
            /// <summary>Returns the shortest distance from the user's avatar to the Play Area's bounds.</summary>
            /// <param name="ignoreHeight">Determines whether the distance should ignore differences in height between the point and the Play Area's bounds. <strong>True</strong> by default.</param>
            /// <param name="unsigned">Determines whether the distance is returned as an unsigned (absolute) value. <strong>True</strong> by default.</param>
            /// <returns>The distance expressed in worldspace units (equivalent to meters).</returns>
            public float getDistance(bool unsigned = true, bool ignoreHeight = true) {
                float distance = new float();
                if (HMDSimulator.simulateControllers) {
                    distance = getDistance(HMDSimulator.getCamera.position, HMDSimulator.leftController.position, HMDSimulator.rightController.position, unsigned, ignoreHeight);
                } else {
                    distance = getDistance(HMDSimulator.getCamera.position, unsigned, ignoreHeight);
                }
                return distance;
            }

            float maxBoundaryX {
                get {
                    float[] xValueArray = new float[verticesList.Count];
                    int n = xValueArray.Length;

                    for (int x = 0; x < n; x++) {
                        xValueArray[x] = verticesList[x].x;
                    }

                    return xValueArray.Max();
                }
            }

            float minBoundaryX {
                get {
                    float[] xValueArray = new float[verticesList.Count];
                    int n = xValueArray.Length;

                    for (int x = 0; x < n; x++) {
                        xValueArray[x] = verticesList[x].x;
                    }

                    return xValueArray.Min();
                }
            }

            float maxBoundaryZ {
                get {
                    float[] zValueArray = new float[verticesList.Count];
                    int n = zValueArray.Length;

                    for (int x = 0; x < n; x++) {
                        zValueArray[x] = verticesList[x].z;
                    }

                    return zValueArray.Max();
                }
            }

            float minBoundaryZ {
                get {
                    float[] zValueArray = new float[verticesList.Count];
                    int n = zValueArray.Length;

                    for (int x = 0; x < n; x++) {
                        zValueArray[x] = verticesList[x].z;
                    }

                    return zValueArray.Min();
                }
            }

            /// <summary>Determines whether the point is within the Play Area's bounds.</summary>
            /// <param name="point">The point expressed as a <see cref="!:https://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</see> in worldspace that will be evaluated
            /// as to its position within the Play Area's bounds.</param>
            /// <returns>
            ///   <strong>true</strong> if the point is within the Play Area's bounds, <strong>false</strong> if not.</returns>
            public bool isWithinBoundary(Vector3 point) {
                bool isXInside = false;
                bool isZInside = false;
                bool isPointInside = false;

                if (point.x < maxBoundaryX && point.x > minBoundaryX) {
                    isXInside = true;
                }
                if (point.z < maxBoundaryZ && point.z > minBoundaryZ) {
                    isZInside = true;
                }

                isPointInside = isXInside == true && isZInside == true;

                return isPointInside;
            }
            /// <summary>Determines whether the three points provided are within the Play Area's bounds.</summary>
            /// <param name="cameraPosition">The position in worldspace of the camera.</param>
            /// <param name="leftControllerPosition">The position in worldspace of the left-hand controller.</param>
            /// <param name="rightControllerPosition">The position in worldspace of the right-hand controller.</param>
            /// <returns>
            ///   <strong>true</strong> if all three points are within the Play Area's bounds, otherwise <strong>false</strong>.</returns>
            public bool isWithinBoundary(Vector3 cameraPosition, Vector3 leftControllerPosition, Vector3 rightControllerPosition) {
                bool areNodesInside = false;

                bool isCameraInside = isWithinBoundary(cameraPosition);
                bool isLeftControllerInside = isWithinBoundary(leftControllerPosition);
                bool isRightControllerInside = isWithinBoundary(rightControllerPosition);

                areNodesInside = isCameraInside == true && isLeftControllerInside == true && isRightControllerInside == true;

                return areNodesInside;
            }
            /// <summary>Determines whether the user's avatar is within the Play Area's bounds.</summary>
            /// <returns>
            ///   <strong>true</strong> if the user's avatar (including camera and controllers) is within the Play Area's bounds, otherwise <strong>false</strong>.</returns>
            public bool isWithinBoundary() {
                bool isCameraInside = isWithinBoundary(HMDSimulator.getCamera.position);
                bool isLeftControllerInside = true;
                bool isRightControllerInside = true;
                if (HMDSimulator.simulateControllers) {
                    isLeftControllerInside = isWithinBoundary(HMDSimulator.leftController.position);
                    isRightControllerInside = isWithinBoundary(HMDSimulator.rightController.position);
                }

                _isAvatarWithinBoundary = isCameraInside == true && isLeftControllerInside == true && isRightControllerInside == true;

                return _isAvatarWithinBoundary;
            }

            void Start() {
                transform.localPosition = new Vector3(transform.localPosition.x, heightOffset, transform.localPosition.z);
            }

            void FixedUpdate() {
                if (transform.parent != null && Mathf.Approximately(heightOffset, transform.position.y) == false) {
                    _heightAdjustment = heightOffset - transform.parent.localPosition.y;
                    transform.localPosition = new Vector3(0f, _heightAdjustment, 0f);
                }
            }
        }
    }
}